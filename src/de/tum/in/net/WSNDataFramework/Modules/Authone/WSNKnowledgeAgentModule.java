package de.tum.in.net.WSNDataFramework.Modules.Authone;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.apache.commons.codec.binary.Hex;
import org.w3c.dom.NodeList;

import de.tum.in.net.WSNDataFramework.Node;
import de.tum.in.net.WSNDataFramework.WSNModule;
import de.tum.in.net.WSNDataFramework.Events.WSNNodeUpdatedEvent;
import de.tum.in.net.authone.knowledgeagent.client.KnowledgeAgentConnector;
import de.tum.in.net.authone.knowledgeagent.common.helpers.ByteHelper;
import de.tum.in.net.authone.knowledgeagent.common.helpers.XMLHelper;
import de.tum.in.net.authone.knowledgeagent.knowledgestore.exceptions.InsufficientCredentialsException;
import de.tum.in.net.authone.knowledgeagent.knowledgestore.exceptions.InvalidAddressException;
import de.tum.in.net.authone.knowledgeagent.network.exceptions.OperationException;
import de.tum.in.net.authone.knowledgeagent.network.exceptions.TransmissionException;

/***
 * Connects the WSN-Framework with the Authone-Project.
 * Attaches a WSN to the Knowledge-Agent
 * 
 * @author Andreas Hubel, adapted by Andr√© Freitag
 */
public class WSNKnowledgeAgentModule extends WSNModule {

	@Override
	protected void _init() {
		/* initialize the knowledge agent */
		// Configure the log4j system
		//BasicConfigurator.configure();

		// This line initializes the knowledge agent connector, which
		// provides a
		// singleton instance of the connector for all further purposes.
		HashMap<String, Object> properties = new HashMap<String, Object>();
		properties.put("id", "1234028c2a3a2bc9476102bb288234c415a2b01f");
		properties.put("id-type", "fixed");
		properties.put("type", "client");
		KnowledgeAgentConnector.getInstance().setProperties(properties);
		try {
			KnowledgeAgentConnector.getInstance().connect(null);
		} catch (TransmissionException e) {
			e.printStackTrace();
		} catch (OperationException e) {
			e.printStackTrace();
		}


		//KnowledgeAgentConnector connector = KnowledgeAgentConnector.newInstance();
		/* register for events */
		_subscribeTo(WSNNodeUpdatedEvent.class, "_event");
	}

	protected void _event(WSNNodeUpdatedEvent eve) {
		/* register knowledge agent object */
		if (!_knowledgeIDs.containsKey(eve.node().getNodeID())) {
			// At this point the listener creates a new knowledge
			// object and registers it at the local knowledge agent. In
			// the future, i.e. once the model repository is in a better
			// state, this would be also the time and place to create a
			// model out of the template. AFAIK this will be a piece of
			// this <)

			// *********************************************************
			// Creating the list of models
			List<String> models = new LinkedList<String>();
			models.add("hardware/sensors/IPFixSensor");

			// Create a dummy object representation to feed to the agent
			org.w3c.dom.Document root = XMLHelper
					.getDocumentFromString("<object-temp><context></context><data></data></object-temp>");
			XPath xpath = XPathFactory.newInstance().newXPath();

			// The required id is a 160bit element, so its generated by
			// a SHA1 hash of the template id.

			String knowledgeObjectID=null;
			try {
				MessageDigest md = MessageDigest.getInstance("SHA-1");

				knowledgeObjectID = Hex.encodeHexString(md
						.digest(ByteHelper.getByte(Integer.parseInt(eve.node().getNodeID().toString()))));
				_knowledgeIDs.put(eve.node().getNodeID(), knowledgeObjectID);
			} catch (NoSuchAlgorithmException e) {
				e.printStackTrace();
			}

			// FIXME Conversion long <--> byte[]
			try {
				KnowledgeAgentConnector.getInstance().register(
						knowledgeObjectID,
						models,
						null,
						false,
						false,
						(org.w3c.dom.Node) xpath.evaluate("/object-temp/context", root,
								XPathConstants.NODE),
								(NodeList) xpath.evaluate("/object-temp/data",
										root, XPathConstants.NODESET), null);
			} catch (InsufficientCredentialsException e) {
				e.printStackTrace();
			} catch (TransmissionException e) {
				e.printStackTrace();
			} catch (OperationException e) {
				e.printStackTrace();
			} catch (XPathExpressionException e) {
				e.printStackTrace();
			}

			// *********************************************************
		}

		/* update the knowledge agent */
		for (Node.Datum f: eve.node().data()) {
			// This value is for the representation within the
			// knowledge plane. The setting of this value for the
			// numeric options isn't the nicest solution. Maybe a
			// better solution will come up after 5 beers.
			String valueRepresentation = "float";

			// The address is generated outside for better
			// understanding. The knowledge object id is created
			// once the template becomes available and is stored in
			// the template itself. This allows to recall this
			// without calculating the digest every time
			String address = "node[@id='"
					+ _knowledgeIDs.get(eve.node().getNodeID())
					+ "']/data/" + f.getName();
			// And push it!
			try {
				KnowledgeAgentConnector.getInstance().set(address,
						valueRepresentation, null);
			} catch (InvalidAddressException e) {
				e.printStackTrace();
			} catch (InsufficientCredentialsException e) {
				e.printStackTrace();
			} catch (TransmissionException e) {
				e.printStackTrace();
			} catch (OperationException e) {
				e.printStackTrace();
			}
		}
	}

	protected Map<Object,String> _knowledgeIDs=new HashMap<Object,String>();
}
